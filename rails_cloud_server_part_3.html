<p><link href='style.css' media='screen' rel='stylesheet' type='text/css' /></p>

<h1>Simple Rails Cloud Server Setup ( Part 3)</h1>

<p><a href="rails_cloud_server_part_1.html">Part 1</a> <a href="rails_cloud_server_part_2.html">Part 2</a> Part 3</p>

<p>Now that we have a Rackspace Cloud server with a useful rails stack running. It is about time for us to show you how to easily, and consistantly deploy your code. Although it is possible so use simple tools such as scp, or even ftp to simply transfer the working files to production, and trigger a reload of the environment, it is not good practice. First of all we are all human, and we make mistakes. If we can automate something simply, it will prevent simple or stupid mistakes from occuring. With more complex installations, a deployment could easily be across multiple machines, and be more then just source code changes. This article will describe one of the many methods and workflows used to deploy, manage, and even rollback production Rails environemnts.</p>

<h2>Tools of the trade</h2>

<ul>
<li>git</li>
<li>github</li>
<li>ssh-keys</li>
<li>capistrano</li>
<li>everything covered in <a href="rails_cloud_server_part_1.html%20and%20[Part%202](rails_cloud_server_part_2.html">Part 1</a></li>
</ul>


<h3>Getting Started</h3>

<p>This article assumes a running server as described in <a href="rails_cloud_server_part_1.html%20and%20[Part%202](rails_cloud_server_part_2.html">Part 1</a>, and a local development similar to the <a href="ruby_environment">Ruby Environment</a> described in the the previous article. Once deployment is setup, it is fairly rock solid, and will ease future releasing, and hopefully unessessary rollbacks.</p>

<p>For this article, we will start by creating a simple local Rails application, and configure it to deploy to our remote server.</p>

<p>First we will need to install rails and bundler.
First lets make sure we are using the ruby we expect, this can be checked simply by typing</p>

<pre><code>ruby -v 
// to see the version

or 
which -a ruby
// to see the path
</code></pre>

<p>You should see ree as the current ruby, if use rvm to switch to the correct ruby and then set it as the default ruby.</p>

<pre><code>rvm use ree --default
</code></pre>

<p>Now that we are using the correct ruby, we need to install some dependencies.</p>

<pre><code>gem install rails bundler capistrano
</code></pre>

<p>and lets generate a dummy rails application</p>

<pre><code>rails new blog

cd blog
</code></pre>

<p>now we should make sure all the gem requirements have been filled.</p>

<pre><code>bundle install
</code></pre>

<p>next, we woant all commands to use the bundled gem environment, to accomplish this we prefix each command with</p>

<pre><code>bundle exec &lt;regular command&gt;
</code></pre>

<p>this ensures the correct gems are loaded.</p>

<p>To generate our first rails scaffold we simple</p>

<pre><code>bundle exec rails generate scaffold post name:string body:text
</code></pre>

<p>Run the database migrations, which will setup our posts table.</p>

<pre><code>bundle exec rake db:migrate

bundle exec rails server
</code></pre>

<p>Lets checkout your super simple, and trivial blog, by surfing over to:</p>

<pre><code>http://127.0.0.1:3000/posts
</code></pre>

<h3>ssh-keys</h3>

<p>We will be using ssh-keys for authentication... blurp. If you already have a key-pair feel free to skip this section.</p>

<pre><code>ssh-keygen -t rsa -C "&lt;your@email.com"
</code></pre>

<p>Now your public key ( you can share this with others) exists at.</p>

<pre><code>~/.ssh/id_rsa.pub
</code></pre>

<p>And, your private key ( do not share this with others) exists at.</p>

<pre><code>~/.ssh/id_rsa
</code></pre>

<h4>Further reading</h4>

<p>*<a href="http://help.github.com/mac-key-setup/">http://help.github.com/mac-key-setup/</a></p>

<h3>Git</h3>

<p>Git is a source control management system, it is a beautiful simple but incredibly powerfull tool. A highly recommended read is the <a href="http://ftp.newartisans.com/pub/git.from.bottom.up.pdf">Git from the bottom up</a> paper, which nicely explains and describes whats going on internally.</p>

<p>For deployment, and collaboration (as mentioned in the <a href="distributed_workflow.html">Distributed Workflow</a>) article) using a centralized git location is very useful. For this we will use <a href="http://github.com/">Github</a>. Github offers free plans, which allow unlimited public repositories, and paid plans, which offer a set number of private repositories, and also unlimited public repositores.</p>

<p>If you dont already have a github account, head over to <a href="http://github.com/">Github.com</a>, signup. Once you have signed up, its time to create a new repository on Github. It is not required that you setup a github repository first, you can always push any repository up to a new github account, if down the road you decide to. Now that you have a new github repository lets push your new simple blog to it, simply follow the instructions on empty github repository page to accomplish this.</p>

<p>At the time of this writing those steps where:</p>

<pre><code>// inside the root of your blog application
git init
git commit -m 'first commit'
git remote add origin git@github.com:stefanpenner/blog.git
git push origin master
</code></pre>

<p>Now if you refresh your blogs github repository page, the page should show the full directory structure and all the source files of your rails application.</p>

<h4>More Git Info</h4>

<p><em><a href="http://help.github.com/">http://help.github.com/</a>
</em><a href="http://book.git-scm.org">The Git Book</a>
<em><a href="http://git-scm.org">http://git-scm.org</a>
</em><a href="http://ftp.newartisans.com/pub/git.from.bottom.up.pdf">Git from the bottom up</a></p>

<h3>Capistrano</h3>

<p>Capistrano is a deployment tool for written in ruby, initial use to deploy ruby applications, such as rails. But can be used for quite literaly anything, even remote server admin. By configuring Capistrano simple deploy.rb DSL, it will do all the heavy lifting for you. Such as, deployments, rollbacks, database migrations, starting and stoping daemons, and configuration environments.</p>

<pre><code>capify .
</code></pre>

<p>This generates the following files.</p>

<pre><code>./Capfile
./config/deploy.rb
</code></pre>

<p>The first ./Capfile we can simply ignore, the second confg/deploy.rb is where we configure the magic.</p>

<p>The first part is straight forward, lets give you application a name, specify the remote repository, and set the scm to git.</p>

<pre><code>set :application, "set your application name here"
set :repository,  "git@github.com:&lt;username&gt;/&lt;repo_name&gt;.git"
set :scm, "git"
</code></pre>

<p>Since we have our permissions setup correctly on our server, we should not need to use sudo when deploying</p>

<pre><code>set :use_sudo, false
</code></pre>

<p>This is where capistrano truely shines, multiple server deployments. By specificying seperate servers or arrays of servers for  :app, :web, :db, we can let capistrano handle deployment to N servers, database migrations to N servers, unfortunately our simple blog application does not (yet) need this scale of archicture, so we can simply bunch, :app, :web, :db together.</p>

<pre><code>server "&lt;ip of your rackspace server&gt;", :app, :web, :db, :primary =&gt; true
</code></pre>

<p>Since we are using RVM on our server, we will have to enable the rvm/capistrano helper. This automatically sets the correct environment variables to use the rvm Ruby associated with your passenger installtion.</p>

<pre><code>$:.unshift(File.expand_path('./lib', ENV['rvm_path'])) # Add RVM's lib directory to the load path.
require "rvm/capistrano"  

set :rvm_ruby_string, "ree@passenger"        # Or whatever env you want it to run in.
set :rvm_type, :user
</code></pre>

<p>In the past, or under other system setups rails stack deployments required restarting various services, since we are using passenger as our webserver. We only need to touch a single file in your applications tmp directory, and on the next request passenger will automatically reboot our application.</p>

<pre><code>namespace :deploy do
  # passenger stuff
  task :start, :roles =&gt; :app do
    run "touch #{release_path}/tmp/restart.txt"
  end

  task :stop, :roles =&gt; :app do
    run "touch #{current_path}/tmp/restart.txt"
  end
  # end passenger stuff
  desc "Restart Application"
  task :restart, :roles =&gt; :app do
    run "touch #{current_path}/tmp/restart.txt"
  end
</code></pre>

<p>In order to run migrations with Rails using bundler, we need to make capistrano aware that it should use bundler.</p>

<pre><code>  # helpers to migrate with bundler
  desc "Run the migrate rake task."  
  task :migrate, :roles =&gt; :app do
    run "cd #{current_path} &amp;&amp; bundle exec rake db:migrate RAILS_ENV=#{rails_env}"
  end
end
</code></pre>

<p>Now that all the hard work is done, we simply issue the following command in the local blog directory, and our application is deploy, and remote database configured.
  cap deploy:setup deploy deploy:migrate</p>

<h4>Further Reading</h4>

<p>*<a href="http://www.capify.org/index.php/From_The_Beginning">http://www.capify.org/index.php/From_The_Beginning</a></p>
